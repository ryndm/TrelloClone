package com.example.ood_project.controllers;

import com.example.ood_project.exceptions.NotFoundException;
import com.example.ood_project.models.*;
import com.example.ood_project.repositories.CommentRepository;
import com.example.ood_project.repositories.TaskRepository;
import com.example.ood_project.repositories.UserRepository;
import jakarta.validation.Valid;
import com.example.ood_project.models.AverageAnalytics;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.Observable;
import java.util.Observer;

@Controller // This means that this class is a Controller
@RequestMapping(path="/tasks") // This means URL's start with /tasks (after Application path)
public class TaskController implements Observer {
    private final TaskAssignmentObservable taskAssignmentObservable = new TaskAssignmentObservable();

    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private TaskRepository taskRepository;
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private CommentRepository commentRepository;
    private final Stack<TaskMemento> taskHistory = new Stack<>();

    @PostMapping(path="") // Map ONLY POST Requests
    public @ResponseBody Task addNewTask (@Valid @RequestBody Task task) throws NotFoundException {
        // @ResponseBody means the returned String is the response, not a view name
        // @RequestParam means it is a parameter from the GET or POST request
        Set<User> users = task.getUsers();
        Task newTask =  taskRepository.save(task);

        if (users != null) {
            for (User user : users) {
                Long userId = user.getId();
                User _user = userRepository.findById(userId)
                        .orElseThrow(() -> new NotFoundException("User not found."));
                _user.getTasks().add(newTask);
                userRepository.save(_user);
                taskAssignmentObservable.taskAssigned(userId);
            }
        }
        return newTask;
    }

    @Override
    public void update(Observable o, Object userName) {
        if (userName instanceof String) {
            System.out.println("User " + userName + " has been assigned a new task.");
        }
    }

    @GetMapping(path="")
    public @ResponseBody Iterable<Task> getAllTasks() {
        // This returns a JSON or XML with the tasks

        // Add pagination, filtering etc.
        return taskRepository.findAll();
    }
    @GetMapping(path="/getTasksByStatus")
    public @ResponseBody Iterable<Task> getTasksByStatus(@RequestBody TaskState state) {
        List<Task> tasks = taskRepository.findByState(state);
        return tasks;
    }
//    @GetMapping(path="/getTasksByAssignee")
//    public @ResponseBody Iterable<Task> getTasksByAssignee(@RequestBody String user) {
//        List<Task> tasks = taskRepository.findByAssignee(user);
//        return tasks;
//    }

    @GetMapping(path="/getTaskByTitle")
    public @ResponseBody Iterable<Task> getTasksByTitle(@RequestBody String title) {
        List<Task> tasks = taskRepository.findByTitle(title);
        return tasks;
    }

    @GetMapping(path="/{id}")
    public @ResponseBody Optional<Task> getTask(@PathVariable long id) {
        // This returns a JSON or XML with the tasks
        return taskRepository.findById(id);
    }

    @DeleteMapping(path="/{id}")
    public @ResponseBody String deleteTask (@PathVariable long id) throws NotFoundException {
        Optional<Task> deletedTask = taskRepository.findById(id);
        return taskRepository.findById(id)
                .map(task -> {
                    Task deleteTask = deletedTask.get();
                    TaskMemento memento = new TaskMemento(task);
                    for(User user : task.getUsers()) {
                        Long userId = user.getId();
                        User _user = null;
                        try {
                            _user = userRepository.findById(userId)
                                    .orElseThrow(() -> new NotFoundException("User not found."));
                        } catch (NotFoundException e) {
                            throw new RuntimeException(e);
                        }
                        if(_user.getTasks().contains(task)) {
                            _user.getTasks().remove(task);
                        }
                        userRepository.save(_user);
                    }
                    taskRepository.deleteById(id);
                    taskHistory.push(memento);
                    return "Task with ID " + id + " deleted successfully";
                })
                .orElseThrow(() -> new NotFoundException("Task with ID " + id + " not found"));
    }

    @PostMapping(path="/undoDelete")
    public @ResponseBody String undoDelete() throws NotFoundException {
        if (!taskHistory.isEmpty()) {
            TaskMemento lastMemento = taskHistory.pop();
            Task taskToRestore = taskRepository.save(lastMemento.getTask());
            Set<User> users = taskToRestore.getUsers();

            for (User user : users) {
                Long userId = user.getId();
                User _user = userRepository.findById(userId)
                        .orElseThrow(() -> new NotFoundException("User not found."));
                _user.getTasks().add(taskToRestore);
                userRepository.save(_user);
                taskAssignmentObservable.taskAssigned(userId);
            }

            return "Last delete operation undone.";
        } else {
            return "No delete operation to undo.";
        }
    }

    @PutMapping(path="/{id}")
    public @ResponseBody Task modifyTask(@PathVariable long id, @Valid @RequestBody Task task) throws Exception {
        return taskRepository.findById(id)
                .map(existingTask -> {
                    if (task.getTitle() != null)
                        existingTask.setTitle(task.getTitle());
                    if (task.getUsers() != null) {
//                        existingTask.setUsers(task.getUsers());

                        for (User user : task.getUsers()) {
                            Long userId = user.getId();
                            User _user = null;
                            try {
                                _user = userRepository.findById(userId)
                                        .orElseThrow(() -> new NotFoundException("User not found."));
                            } catch (NotFoundException e) {
                                throw new RuntimeException(e);
                            }
                            _user.getTasks().add(task);
                            userRepository.save(_user);
                            taskAssignmentObservable.taskAssigned(userId);
                        }
                    }

                    if (task.getState() != null) {
                        // Check if state is changed and modify the analytics fields accordingly
                        if (existingTask.getState() != task.getState()) {
                            System.out.println("Inside Loop");
                           if (existingTask.getState() == TaskState.DOING) {
                               existingTask.setTimeInDoing(ChronoUnit.SECONDS.between(existingTask.getLastStateChange(), LocalDateTime.now()));
                           } else if (existingTask.getState() == TaskState.TODO) {
                               existingTask.setTimeInToDo(ChronoUnit.SECONDS.between(existingTask.getLastStateChange(), LocalDateTime.now()));
                           }
                           existingTask.setLastStateChange(LocalDateTime.now());
                        }
                        existingTask.setState(task.getState());
                    }

                    if (task.getDescription() != null)
                        existingTask.setDescription(task.getDescription());

//                    if (task.getComments() != null) {
//                        List<String> commentsList = new ArrayList<String>();
//                        if (existingTask.getComments() != null)
//                            commentsList.addAll(existingTask.getComments());
//                        commentsList.addAll(task.getComments());
//                        existingTask.setComments(commentsList);
//                    }

                    return taskRepository.save(existingTask);
                })
                .orElseThrow(() -> new NotFoundException("Task with ID " + id + " not found"));

        // Modify Task API PutMapping
        // Validation needed
        // is the task present etc.

        // Delete Task API DeleteMapping
        // is the task present.
    }

    @PostMapping(path="/{id}/comment")
    public @ResponseBody String addComment(@PathVariable Long id, @Valid @RequestBody Comment comment) throws NotFoundException {
        Comment newComment = commentRepository.save(comment);
        return taskRepository.findById(id)
                .map(task -> {
                    newComment.setTask(task);
                    task.getComments().add(comment);
                    taskRepository.save(task);
                    return "Comment saved successfully.";
                }).orElseThrow(() -> new NotFoundException("Didn't find task with id " + id));
    }

    @GetMapping(path="/analytics/average")
    public ResponseEntity<Map<String, String>> getAnalytics() {
        Iterable<Task> tasks = taskRepository.findAll();
        return ResponseEntity.ok(new AverageAnalytics(tasks).getAnalytics());
    }
}
